<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>清吧吧台与代码显示屏背景</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0a0a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        /* 背景代码显示屏 */
        .code-display {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #0f0;
            text-shadow: 0 0 8px #0f0, 0 0 16px #0f0;
            overflow: hidden;
            animation: screenFlicker 0.2s infinite linear;
            /* 像素风效果 */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            /* 光栅效果 */
            background-image: 
                linear-gradient(90deg, transparent 98%, rgba(0, 255, 0, 0.03) 100%),
                linear-gradient(0deg, transparent 98%, rgba(0, 255, 0, 0.03) 100%);
            background-size: 2px 2px;
            /* GPU加速 */
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* 酒吧名称 - 红弦俱乐部风格 */
        .bar-name {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 8;
            pointer-events: none;
        }
        
        .bar-name-text {
            font-family: 'Brush Script MT', 'Lucida Handwriting', 'Comic Sans MS', cursive;
            font-size: 62px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 30px #00ffff,
                0 0 40px #00ffff,
                2px 2px 0px #ff00ff,
                4px 4px 0px #ff00ff;
            letter-spacing: 4px;
            text-transform: uppercase;
            animation: barNameGlow 3s ease-in-out infinite alternate;
            position: relative;
            z-index: 2;
            display: inline-block;
            font-style: italic;
        }
        
        @keyframes barNameGlow {
            0% {
                color: #00ffff;
                text-shadow: 
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 40px #00ffff,
                    2px 2px 0px #ff00ff,
                    4px 4px 0px #ff00ff;
            }
            100% {
                color: #ff00ff;
                text-shadow: 
                    0 0 10px #ff00ff,
                    0 0 20px #ff00ff,
                    0 0 30px #ff00ff,
                    0 0 40px #ff00ff,
                    2px 2px 0px #00ffff,
                    4px 4px 0px #00ffff;
            }
        }
        
        /* 算法可视化容器 */
        .algorithm-visualization {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            opacity: 0.3;
        }
        
        /* 递归树 */
        .recursive-tree {
            position: absolute;
            top: 50%;
            left: 20%;
            width: 300px;
            height: 300px;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .tree-node {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ff00;
            animation: nodePulse 2s ease-in-out infinite;
        }
        
        .tree-line {
            position: absolute;
            background: linear-gradient(45deg, #00ff00, #00ffff);
            height: 2px;
            transform-origin: left center;
            box-shadow: 0 0 5px #00ff00;
        }
        
        @keyframes nodePulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.5);
                opacity: 1;
            }
        }
        
        /* 神经网络 */
        .neural-network {
            position: absolute;
            top: 20%;
            right: 15%;
            width: 400px;
            height: 250px;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .neuron {
            position: absolute;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #ff00ff, #ff0080);
            border-radius: 50%;
            box-shadow: 0 0 15px #ff00ff;
            animation: neuronFire 1.5s ease-in-out infinite;
        }
        
        .neural-connection {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, #ff00ff, transparent);
            box-shadow: 0 0 3px #ff00ff;
            animation: signalFlow 2s linear infinite;
        }
        
        @keyframes neuronFire {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.6;
            }
            50% { 
                transform: scale(1.3);
                opacity: 1;
            }
        }
        
        @keyframes signalFlow {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* 排序算法 */
        .sorting-algorithm {
            position: absolute;
            bottom: 10%;
            left: 10%;
            width: 350px;
            height: 200px;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .sort-bar {
            position: absolute;
            bottom: 0;
            background: linear-gradient(to top, #00ffff, #0080ff);
            border-radius: 2px 2px 0 0;
            box-shadow: 0 0 8px #00ffff;
            transition: all 0.3s ease;
        }
        
        .sort-bar.comparing {
            background: linear-gradient(to top, #ffff00, #ff8000);
            box-shadow: 0 0 12px #ffff00;
        }
        
        .sort-bar.sorted {
            background: linear-gradient(to top, #00ff00, #00ff80);
            box-shadow: 0 0 10px #00ff00;
        }
        
        /* 线性回归 */
        .linear-regression {
            position: absolute;
            top: 30%;
            right: 5%;
            width: 300px;
            height: 200px;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .data-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffff00;
            border-radius: 50%;
            box-shadow: 0 0 8px #ffff00;
            animation: dataPointGlow 3s ease-in-out infinite;
        }
        
        .regression-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            box-shadow: 0 0 6px #ff00ff;
            transform-origin: left center;
            animation: lineGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes dataPointGlow {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.3);
                opacity: 1;
            }
        }
        
        @keyframes lineGlow {
            0% { 
                box-shadow: 0 0 6px #ff00ff;
            }
            100% { 
                box-shadow: 0 0 12px #00ffff;
            }
        }
        
        /* 聚类算法 */
        .clustering {
            position: absolute;
            top: 60%;
            left: 5%;
            width: 250px;
            height: 250px;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }
        
        .cluster-point {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            box-shadow: 0 0 10px;
            animation: clusterPulse 2s ease-in-out infinite;
        }
        
        .cluster-point.cluster-1 {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }
        
        .cluster-point.cluster-2 {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .cluster-point.cluster-3 {
            background: #0000ff;
            box-shadow: 0 0 10px #0000ff;
        }
        
        .cluster-center {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            box-shadow: 0 0 15px;
            animation: centerPulse 1.5s ease-in-out infinite;
        }
        
        .cluster-center.center-1 {
            background: #ff8080;
            box-shadow: 0 0 15px #ff0000;
        }
        
        .cluster-center.center-2 {
            background: #80ff80;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .cluster-center.center-3 {
            background: #8080ff;
            box-shadow: 0 0 15px #0000ff;
        }
        
        @keyframes clusterPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.7;
            }
            50% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }
        
        @keyframes centerPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.4);
                opacity: 1;
            }
        }
        
        /* 音浪效果容器 */
        .audio-waves {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 12;
            pointer-events: none;
            opacity: 0.6;
        }
        
        /* 音浪条 */
        .wave-bar {
            position: absolute;
            bottom: 180px;
            width: 4px;
            background: linear-gradient(to top, 
                rgba(0, 255, 0, 1) 0%, 
                rgba(0, 255, 255, 0.8) 50%, 
                rgba(255, 0, 255, 0.6) 100%);
            border-radius: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
            height: 100px;
            opacity: 0.6;
            animation: waveFadeIn 0.5s ease-out forwards;
            transition: all 0.1s ease-out;
        }
        
        /* 音浪动画 - 从左到右依次变高 */
        @keyframes waveAnimation {
            0% { 
                height: 20px; 
                opacity: 0.6;
            }
            25% { 
                height: 80px; 
                opacity: 0.8;
            }
            50% { 
                height: 150px; 
                opacity: 1;
            }
            75% { 
                height: 80px; 
                opacity: 0.8;
            }
            100% { 
                height: 20px; 
                opacity: 0.6;
            }
        }
        
        /* 音浪渐显动画 */
        @keyframes waveFadeIn {
            from {
                opacity: 0;
                transform: scaleY(0);
            }
            to {
                opacity: 1;
                transform: scaleY(1);
            }
        }
        
        /* 音浪条位置和延迟将通过JavaScript动态设置 */
        
        /* 边框层 - 最顶层 */
        .border-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
            /* 赛博朋克荧光边框效果 */
            border: 8px solid #00ffff;
            box-shadow: 
                inset 0 0 0 4px #ff00ff,
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 30px #00ffff,
                0 0 40px #00ffff,
                inset 0 0 10px #ff00ff,
                inset 0 0 20px #ff00ff,
                0 0 50px rgba(0, 255, 255, 0.8),
                0 0 80px rgba(255, 0, 255, 0.6);
            animation: neonGlow 2s ease-in-out infinite alternate;
        }
        
        .code-line {
            margin-bottom: 8px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 2;
        }
        
        .code-char {
            display: inline-block;
            animation: charFlicker 1s infinite ease-in-out;
            animation-delay: calc(var(--char-index) * 0.1s);
            /* 像素风字符效果 */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            /* 字符像素化 */
            transform: scale(1);
            filter: contrast(1.2) brightness(1.1);
            will-change: opacity, filter;
        }
        
        
        @keyframes charFlicker {
            0%, 100% { 
                opacity: 1; 
                text-shadow: 0 0 8px #0f0, 0 0 16px #0f0;
                filter: contrast(1.2) brightness(1.1);
                transform: scale(1);
            }
            25% { 
                opacity: 0.3; 
                text-shadow: 0 0 4px #0f0;
                filter: contrast(0.8) brightness(0.8);
                transform: scale(0.98);
            }
            50% { 
                opacity: 0.8; 
                text-shadow: 0 0 12px #0f0, 0 0 20px #0f0;
                filter: contrast(1.5) brightness(1.3);
                transform: scale(1.02);
            }
            75% { 
                opacity: 0.5; 
                text-shadow: 0 0 6px #0f0;
                filter: contrast(1.0) brightness(0.9);
                transform: scale(0.99);
            }
        }
        
        
        @keyframes screenFlicker {
            0%, 100% { opacity: 1; }
            99% { opacity: 0.98; }
        }
        
        /* 光栅扫描线效果 */
        .code-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                0deg,
                transparent 0%,
                rgba(0, 255, 0, 0.1) 1px,
                transparent 2px,
                transparent 100%
            );
            background-size: 100% 3px;
            animation: scanlineMove 0.1s linear infinite;
            pointer-events: none;
            z-index: 1;
        }
        
        /* 像素网格效果 */
        .code-display::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 8px 8px;
            animation: pixelGrid 2s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        }
        
        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(3px); }
        }
        
        @keyframes pixelGrid {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.1; }
        }
        
        @keyframes neonGlow {
            0% {
                border-color: #00ffff;
                box-shadow: 
                    inset 0 0 0 4px #ff00ff,
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 40px #00ffff,
                    inset 0 0 10px #ff00ff,
                    inset 0 0 20px #ff00ff,
                    0 0 50px rgba(0, 255, 255, 0.8),
                    0 0 80px rgba(255, 0, 255, 0.6);
            }
            50% {
                border-color: #00ccff;
                box-shadow: 
                    inset 0 0 0 4px #ff33ff,
                    0 0 15px #00ccff,
                    0 0 30px #00ccff,
                    0 0 45px #00ccff,
                    0 0 60px #00ccff,
                    inset 0 0 15px #ff33ff,
                    inset 0 0 30px #ff33ff,
                    0 0 70px rgba(0, 204, 255, 1),
                    0 0 100px rgba(255, 51, 255, 0.8);
            }
            100% {
                border-color: #0099ff;
                box-shadow: 
                    inset 0 0 0 4px #ff66ff,
                    0 0 20px #0099ff,
                    0 0 40px #0099ff,
                    0 0 60px #0099ff,
                    0 0 80px #0099ff,
                    inset 0 0 20px #ff66ff,
                    inset 0 0 40px #ff66ff,
                    0 0 90px rgba(0, 153, 255, 1.2),
                    0 0 120px rgba(255, 102, 255, 1);
            }
        }
        
        @keyframes scrollUp {
            0% { transform: translateY(100%); }
            100% { transform: translateY(-100%); }
        }
        
        .scrolling-line {
            animation: scrollUp 3s linear infinite;
            animation-delay: calc(var(--line-index) * 0.2s);
        }
        
        /* 吧台前景 */
        .bar-foreground {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-top: 200px;
            pointer-events: none;
        }
        
        /* 吧台光栅效果层 */
        .bar-foreground::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(90deg, transparent 98%, rgba(255, 255, 255, 0.08) 100%),
                linear-gradient(0deg, transparent 98%, rgba(255, 255, 255, 0.08) 100%);
            background-size: 3px 3px;
            background-repeat: repeat;
            pointer-events: none;
            z-index: 1;
        }
        
        .bar-foreground * {
            pointer-events: auto;
        }
        
        /* 对话系统样式 */
        .dialogue-container {
            position: absolute;
            top: 70px;
            left: 800px;
            z-index: 50;
            pointer-events: auto;
            max-height: 200px;
        }
        
        /* 鸡尾酒显示区域 */
        .cocktail-display {
            position: absolute;
            bottom: 90px;
            left: 30%;
            transform: translateX(-50%);
            z-index: 20;
            pointer-events: auto;
            opacity: 0;
            transition: all 0.8s ease-in-out;
        }
        
        .cocktail-display.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-20px);
        }
        
        .cocktail-image {
            width: 220px;
            height: 320px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.3));
        }
        
        .cocktail-image:hover {
            transform: scale(1.05);
            filter: drop-shadow(0 15px 30px rgba(0, 0, 0, 0.4)) brightness(1.1);
        }
        
        .cocktail-image:active {
            transform: scale(0.95);
        }
        
        .cocktail-glow {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            animation: cocktailPulse 2s ease-in-out infinite alternate;
            pointer-events: none;
        }
        
        @keyframes cocktailPulse {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 0.8; transform: scale(1.1); }
        }
        
        .dialogue-bubble {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 12px 16px;
            margin-bottom: 10px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 
                0 0 15px rgba(0, 255, 255, 0.5),
                inset 0 0 8px rgba(0, 255, 255, 0.1);
            animation: bubbleGlow 2s ease-in-out infinite alternate;
            max-width: 60%;
            word-wrap: break-word;
        }
        
        .dialogue-bubble.stella {
            margin-left: 0;
            margin-right: auto;
            border-color: #ff00ff;
            box-shadow: 
                0 0 15px rgba(255, 0, 255, 0.5),
                inset 0 0 8px rgba(255, 0, 255, 0.1);
            max-width: 50%;
        }
        
        .dialogue-bubble.user {
            margin-left: auto;
            background: rgba(0, 20, 40, 0.9);
            border-color: #00ff88;
            box-shadow: 
                0 0 20px rgba(0, 255, 136, 0.5),
                inset 0 0 10px rgba(0, 255, 136, 0.1);
        }
        
        .speaker-name {
            color: #00ffff;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ffff;
        }
        
        .speaker-name.stella {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }
        
        .speaker-name.user {
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }
        
        .choice-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .choice-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: 2px solid #00ffff;
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.15s ease;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            will-change: transform, box-shadow, background;
        }
        
        .choice-btn:hover {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            border-color: #00ff88;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            transform: translateY(-2px);
        }
        
        .choice-btn:active {
            transform: translateY(0);
        }
        
        .recording-btn {
            background: linear-gradient(45deg, #ff0088, #ff4488);
            border: 2px solid #ff00ff;
            color: #fff;
            padding: 15px 30px;
            border-radius: 30px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 0, 136, 0.5);
            margin: 10px 0;
        }
        
        .recording-btn:hover {
            background: linear-gradient(45deg, #ff4488, #ff88aa);
            box-shadow: 0 0 30px rgba(255, 0, 136, 0.8);
            transform: scale(1.05);
        }
        
        .recording-btn.recording {
            background: linear-gradient(45deg, #ff4444, #ff8888);
            animation: recordingPulse 1s ease-in-out infinite;
        }
        
        @keyframes bubbleGlow {
            0% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1); }
            100% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), inset 0 0 15px rgba(0, 255, 255, 0.2); }
        }
        
        @keyframes recordingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .hidden {
            display: none;
        }
        
        .click-to-continue {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: #00ffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            animation: clickPulse 1.5s ease-in-out infinite;
            pointer-events: none;
            z-index: 10;
        }
        
        .dialogue-bubble {
            position: relative;
            cursor: pointer;
        }
        
        @keyframes clickPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
        
        .bar-counter {
            width: 100%;
            height: 400px;
            /* 默认样式作为后备 */
            background: linear-gradient(to bottom, #3a2c1a, #1a1208);
            border-radius: 0;
            position: relative;
        }
        
        /* 当有图片时覆盖默认样式 */
        .bar-counter.has-image {
            background-image: url('bar-counter.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            background: url('bar-counter.png') center/cover no-repeat;
        }
        
        
        .bartender {
            position: absolute;
            bottom: 170px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 650px;
            z-index: 15;
            /* 默认透明背景 */
            background-color: transparent;
        }
        
        /* 当有图片时显示图片 */
        .bartender.has-image {
            background-image: url('bartender.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
        }
        
        /* 当有图片时隐藏伪元素 */
        .bartender.has-image::before,
        .bartender.has-image::after {
            display: none;
        }
        
        .bartender::before {
            content: '';
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background-color: #f5d7b4;
            border-radius: 50%;
        }
        
        .bartender::after {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 50px;
            background-color: #222;
            border-radius: 50px 50px 0 0;
        }
        
        
        
    </style>
</head>
<body>
    
    <div class="container">
        <!-- 酒吧名称 -->
        <div class="bar-name" id="barName">
            <div class="bar-name-text">RHYTHM</div>
        </div>
        
        <!-- 背景代码显示屏 -->
        <div class="code-display" id="codeDisplay">
            <!-- 音浪效果 -->
            <div class="audio-waves" id="audioWaves">
                <!-- 音浪条将通过JavaScript动态生成 -->
            </div>
            
            <!-- 算法可视化 -->
            <div class="algorithm-visualization" id="algorithmViz">
                <!-- 递归树 -->
                <div class="recursive-tree" id="recursiveTree"></div>
                <!-- 神经网络 -->
                <div class="neural-network" id="neuralNetwork"></div>
                <!-- 排序算法 -->
                <div class="sorting-algorithm" id="sortingAlgorithm"></div>
                <!-- 线性回归 -->
                <div class="linear-regression" id="linearRegression"></div>
                <!-- 聚类算法 -->
                <div class="clustering" id="clustering"></div>
            </div>
            
            <!-- 代码将通过JavaScript动态生成 -->
        </div>
        
        <!-- 前景吧台 -->
        <div class="bar-foreground">
            <div class="bartender"></div>
            <div class="bar-counter"></div>
        </div>
        
        <!-- 鸡尾酒显示区域 -->
        <div class="cocktail-display" id="cocktailDisplay">
            <div class="cocktail-glow"></div>
            <div class="cocktail-image" id="cocktailImage"></div>
    </div>
    
        <!-- 对话系统 -->
        <div class="dialogue-container" id="dialogueContainer">
            <!-- 对话内容将通过JavaScript动态生成 -->
    </div>
    
        <!-- 边框层 - 最顶层 -->
        <div class="border-overlay"></div>
    </div>
    

    <script>
        // 专业的代码模板 - 带缩进和结构
        const codeTemplates = [
            '// ========================================',
            '// 企业级微服务架构 - 用户管理模块',
            '// ========================================',
            '',
            'import { Logger, Database, Redis } from \'@core/services\';',
            'import { UserEntity, UserRole } from \'@entities/user\';',
            'import { ValidationError, BusinessError } from \'@exceptions\';',
            '',
            '/**',
            ' * 用户认证服务类',
            ' * @class AuthenticationService',
            ' */',
            'export class AuthenticationService {',
            '    private readonly logger: Logger;',
            '    private readonly db: Database;',
            '    private readonly redis: Redis;',
            '',
            '    constructor(dependencies: ServiceDependencies) {',
            '        this.logger = dependencies.logger;',
            '        this.db = dependencies.database;',
            '        this.redis = dependencies.redis;',
            '    }',
            '',
            '    /**',
            '     * 用户登录认证',
            '     * @param credentials 用户凭据',
            '     * @returns Promise<AuthResult>',
            '     */',
            '    async authenticateUser(credentials: LoginCredentials): Promise<AuthResult> {',
            '        try {',
            '            const { username, password } = credentials;',
            '            ',
            '            // 参数验证',
            '            if (!username || !password) {',
            '                throw new ValidationError(\'用户名和密码不能为空\');',
            '            }',
            '            ',
            '            // 查询用户信息',
            '            const user = await this.db.query(',
            '                \'SELECT * FROM users WHERE username = ?\',',
            '                [username]',
            '            );',
            '            ',
            '            if (!user) {',
            '                throw new BusinessError(\'用户不存在\');',
            '            }',
            '            ',
            '            // 验证密码',
            '            const isValidPassword = await bcrypt.compare(password, user.passwordHash);',
            '            if (!isValidPassword) {',
            '                throw new BusinessError(\'密码错误\');',
            '            }',
            '            ',
            '            // 生成JWT令牌',
            '            const token = this.generateJWTToken(user);',
            '            ',
            '            // 缓存用户会话',
            '            await this.redis.setex(`session:${user.id}`, 3600, token);',
            '            ',
            '            this.logger.info(`用户 ${username} 登录成功`);',
            '            ',
            '            return {',
            '                success: true,',
            '                token,',
            '                user: this.sanitizeUser(user)',
            '            };',
            '        } catch (error) {',
            '            this.logger.error(\'用户认证失败:\', error);',
            '            throw error;',
            '        }',
            '    }',
            '',
            '    /**',
            '     * 生成JWT令牌',
            '     * @private',
            '     */',
            '    private generateJWTToken(user: UserEntity): string {',
            '        const payload = {',
            '            userId: user.id,',
            '            username: user.username,',
            '            role: user.role,',
            '            iat: Math.floor(Date.now() / 1000),',
            '            exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24小时',
            '        };',
            '        ',
            '        return jwt.sign(payload, process.env.JWT_SECRET!);',
            '    }',
            '}',
            '',
            '/**',
            ' * 用户管理服务类',
            ' * @class UserManagementService',
            ' */',
            'export class UserManagementService {',
            '    private readonly logger: Logger;',
            '    private readonly db: Database;',
            '',
            '    constructor(dependencies: ServiceDependencies) {',
            '        this.logger = dependencies.logger;',
            '        this.db = dependencies.database;',
            '    }',
            '',
            '    /**',
            '     * 创建新用户',
            '     * @param userData 用户数据',
            '     * @returns Promise<UserEntity>',
            '     */',
            '    async createUser(userData: CreateUserRequest): Promise<UserEntity> {',
            '        const transaction = await this.db.beginTransaction();',
            '        ',
            '        try {',
            '            // 数据验证',
            '            await this.validateUserData(userData);',
            '            ',
            '            // 检查用户是否已存在',
            '            const existingUser = await this.db.query(',
            '                \'SELECT id FROM users WHERE email = ?\',',
            '                [userData.email]',
            '            );',
            '            ',
            '            if (existingUser) {',
            '                throw new BusinessError(`邮箱 ${userData.email} 已被注册`);',
            '            }',
            '            ',
            '            // 加密密码',
            '            const passwordHash = await bcrypt.hash(userData.password, 12);',
            '            ',
            '            // 创建用户记录',
            '            const userId = await this.db.query(',
            '                `INSERT INTO users (username, email, password_hash, role, created_at) ',
            '                 VALUES (?, ?, ?, ?, NOW())`,',
            '                [',
            '                    userData.username,',
            '                    userData.email,',
            '                    passwordHash,',
            '                    userData.role || UserRole.USER',
            '                ]',
            '            );',
            '            ',
            '            await transaction.commit();',
            '            ',
            '            this.logger.info(`用户创建成功: ${userData.email}`);',
            '            ',
            '            return await this.getUserById(userId);',
            '        } catch (error) {',
            '            await transaction.rollback();',
            '            this.logger.error(\'用户创建失败:\', error);',
            '            throw error;',
            '        }',
            '    }',
            '}',
            '',
            '// ========================================',
            '// 数据库连接配置',
            '// ========================================',
            '',
            'interface DatabaseConfig {',
            '    host: string;',
            '    port: number;',
            '    username: string;',
            '    password: string;',
            '    database: string;',
            '    pool: {',
            '        min: number;',
            '        max: number;',
            '        acquireTimeoutMillis: number;',
            '        idleTimeoutMillis: number;',
            '    };',
            '}',
            '',
            'const dbConfig: DatabaseConfig = {',
            '    host: process.env.DB_HOST || \'localhost\',',
            '    port: parseInt(process.env.DB_PORT || \'5432\'),',
            '    username: process.env.DB_USERNAME || \'postgres\',',
            '    password: process.env.DB_PASSWORD || \'\',',
            '    database: process.env.DB_NAME || \'app_db\',',
            '    pool: {',
            '        min: 2,',
            '        max: 10,',
            '        acquireTimeoutMillis: 30000,',
            '        idleTimeoutMillis: 30000,',
            '    },',
            '};',
            '',
            '// ========================================',
            '// 工具函数和中间件',
            '// ========================================',
            '',
            '/**',
            ' * 请求日志中间件',
            ' */',
            'export const requestLogger = (req: Request, res: Response, next: NextFunction) => {',
            '    const startTime = Date.now();',
            '    ',
            '    res.on(\'finish\', () => {',
            '        const duration = Date.now() - startTime;',
            '        logger.info(`${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`);',
            '    });',
            '    ',
            '    next();',
            '};',
            '',
            '/**',
            ' * 错误处理中间件',
            ' */',
            'export const errorHandler = (',
            '    error: Error,',
            '    req: Request,',
            '    res: Response,',
            '    next: NextFunction',
            ') => {',
            '    logger.error(\'Unhandled error:\', error);',
            '    ',
            '    if (error instanceof ValidationError) {',
            '        return res.status(400).json({',
            '            error: \'VALIDATION_ERROR\',',
            '            message: error.message,',
            '        });',
            '    }',
            '    ',
            '    if (error instanceof BusinessError) {',
            '        return res.status(409).json({',
            '            error: \'BUSINESS_ERROR\',',
            '            message: error.message,',
            '        });',
            '    }',
            '    ',
            '    res.status(500).json({',
            '        error: \'INTERNAL_SERVER_ERROR\',',
            '        message: \'服务器内部错误\',',
            '    });',
            '};',
            '',
            '// 数据验证工具函数',
            'const validateEmail = (email) => {',
            '    const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
            '    return regex.test(email);',
            '};',
            '',
            '// 缓存管理类',
            'class CacheManager {',
            '    constructor() {',
            '        this.cache = new Map();',
            '        this.ttl = 3600000; // 1小时',
            '    }',
            '',
            '    set(key, value, ttl = this.ttl) {',
            '        const expireTime = Date.now() + ttl;',
            '        this.cache.set(key, { value, expireTime });',
            '    }',
            '',
            '    get(key) {',
            '        const item = this.cache.get(key);',
            '        if (!item) return null;',
            '',
            '        if (Date.now() > item.expireTime) {',
            '            this.cache.delete(key);',
            '            return null;',
            '        }',
            '',
            '        return item.value;',
            '    }',
            '}',
            '',
            '// 错误处理中间件',
            'const errorHandler = (err, req, res, next) => {',
            '    console.error(\'Error:\', err);',
            '    ',
            '    if (err.name === \'ValidationError\') {',
            '        return res.status(400).json({',
            '            error: \'VALIDATION_ERROR\',',
            '            message: err.message',
            '        });',
            '    }',
            '    ',
            '    res.status(500).json({',
            '        error: \'INTERNAL_ERROR\',',
            '        message: \'服务器内部错误\'',
            '    });',
            '};',
            '',
            '// 工具函数集合',
            'const utils = {',
            '    formatDate: (date) => {',
            '        return new Intl.DateTimeFormat(\'zh-CN\').format(date);',
            '    },',
            '    ',
            '    generateId: () => {',
            '        return Math.random().toString(36).substr(2, 9);',
            '    },',
            '    ',
            '    debounce: (func, wait) => {',
            '        let timeout;',
            '        return function executedFunction(...args) {',
            '            const later = () => {',
            '                clearTimeout(timeout);',
            '                func(...args);',
            '            };',
            '            clearTimeout(timeout);',
            '            timeout = setTimeout(later, wait);',
            '        };',
            '    }',
            '};',
            '',
            '// 导出模块',
            'module.exports = {',
            '    AuthenticationService,',
            '    UserService,',
            '    CacheManager,',
            '    errorHandler,',
            '    utils',
            '};'
        ];
        
        // 生成随机代码行 - 长短参差不齐
        function generateCodeLines(count) {
            const lines = [];
            const templates = [...codeTemplates];
            
            for (let i = 0; i < count; i++) {
                // 随机选择模板，增加多样性
                const templateIndex = Math.floor(Math.random() * templates.length);
                let line = templates[templateIndex];
                
                // 如果模板行是等号分隔符，替换为更有意义的代码
                if (line.includes('=') && line.length > 20 && line.includes('//')) {
                    // 生成替代的代码注释
                    const comments = [
                        '// 系统初始化完成',
                        '// 数据库连接已建立',
                        '// 缓存服务启动成功',
                        '// API接口已就绪',
                        '// 用户认证模块加载',
                        '// 日志系统初始化',
                        '// 配置参数验证通过',
                        '// 服务健康检查正常',
                        '// 内存使用率正常',
                        '// 网络连接稳定',
                        '// 微服务架构运行中',
                        '// 负载均衡器状态正常',
                        '// 消息队列处理中',
                        '// 定时任务执行完成',
                        '// 安全策略已更新',
                        '// 性能监控数据收集',
                        '// 用户会话管理正常',
                        '// 文件上传服务就绪',
                        '// 邮件发送队列处理',
                        '// 数据备份任务完成'
                    ];
                    line = comments[Math.floor(Math.random() * comments.length)];
                }
                
                lines.push(line);
            }
            
            return lines;
        }
        
        // 创建代码行
        function createCodeLine(text, lineIndex) {
            const codeLine = document.createElement('div');
            codeLine.className = 'code-line scrolling-line';
            codeLine.style.setProperty('--line-index', lineIndex);
            
            // 逐个字符创建
            for (let i = 0; i < text.length; i++) {
                const charSpan = document.createElement('span');
                charSpan.className = 'code-char';
                charSpan.textContent = text[i];
                charSpan.style.setProperty('--char-index', i);
                codeLine.appendChild(charSpan);
            }
            
            return codeLine;
        }
        
        // 填充代码显示屏
        function populateCodeDisplay() {
            const codeDisplay = document.getElementById('codeDisplay');
            const lines = generateCodeLines(80); // 增加更多行数以显示参差效果
            
            lines.forEach((line, index) => {
                const codeLine = createCodeLine(line, index);
                codeDisplay.appendChild(codeLine);
            });
        }
        
        // 动态添加新代码行
        function addNewCodeLine() {
            const codeDisplay = document.getElementById('codeDisplay');
            const lines = generateCodeLines(1);
            const newLine = createCodeLine(lines[0], codeDisplay.children.length);
            
            codeDisplay.appendChild(newLine);
            
            // 移除最旧的行以保持性能
            if (codeDisplay.children.length > 100) {
                codeDisplay.removeChild(codeDisplay.firstChild);
            }
        }
        
        // 检测图片是否存在并切换样式
        function checkImageExists(imagePath, element, className) {
            const img = new Image();
            img.onload = function() {
                element.classList.add(className);
                console.log(`✅ 图片加载成功: ${imagePath}`);
            };
            img.onerror = function() {
                element.classList.remove(className);
                console.log(`❌ 图片加载失败: ${imagePath}`);
            };
            img.src = imagePath;
        }
        
        // 初始化音浪效果
        function initializeAudioWaves() {
            const audioWaves = document.getElementById('audioWaves');
            
            if (!audioWaves) {
                console.error('音浪容器未找到');
                return;
            }
            
            // 创建40个音浪条
            for (let i = 0; i < 40; i++) {
                const waveBar = document.createElement('div');
                waveBar.className = 'wave-bar';
                
                // 动态设置位置和渐显延迟
                const leftPosition = (i / 39) * 100; // 0% 到 100%
                const fadeInDelay = (i / 39) * 2; // 0s 到 2s 的渐显延迟
                
                waveBar.style.left = leftPosition + '%';
                waveBar.style.animationDelay = fadeInDelay + 's'; // 渐显动画的延迟
                
                audioWaves.appendChild(waveBar);
            }
            
            console.log('音浪效果已初始化，创建了', audioWaves.children.length, '个音浪条');
        }
        
        // 音浪全局变量
        let currentMode = 0;
        const modes = ['wave', 'centerSpread', 'heart', 'spiral', 'random'];
        let modeTimer = 0;
        const modeDuration = 8000; // 每个模式持续8秒
        let waveInterval = null; // 音浪定时器
        
        // 波浪模式 - 从左到右依次变高
        function createWave() {
            const waveBars = document.querySelectorAll('.wave-bar');
            const totalBars = waveBars.length;
            
            waveBars.forEach((bar, index) => {
                const wavePosition = index / (totalBars - 1);
                const wavePhase = (Date.now() / 1000) * 2;
                const waveOffset = wavePosition * Math.PI * 2;
                const waveValue = Math.sin(wavePhase + waveOffset);
                
                const heightMultiplier = (waveValue + 1) / 2 * 0.7 + 0.3;
                const baseHeight = 150;
                const currentHeight = baseHeight * heightMultiplier;
                
                bar.style.height = currentHeight + 'px';
                bar.style.opacity = 0.4 + heightMultiplier * 0.6;
                
                const hue = 120 + wavePosition * 120;
                bar.style.background = `linear-gradient(to top, 
                    hsla(${hue}, 100%, 50%, 1) 0%, 
                    hsla(${hue + 60}, 100%, 50%, 0.8) 50%, 
                    hsla(${hue + 120}, 100%, 50%, 0.6) 100%)`;
            });
        }
        
        // 中间扩散模式
        function createCenterSpread() {
                const waveBars = document.querySelectorAll('.wave-bar');
                const totalBars = waveBars.length;
                const center = totalBars / 2;
                
                waveBars.forEach((bar, index) => {
                    const distanceFromCenter = Math.abs(index - center);
                    const maxDistance = center;
                    const normalizedDistance = distanceFromCenter / maxDistance;
                    
                    const wavePhase = (Date.now() / 1000) * 3;
                    const waveValue = Math.sin(wavePhase - normalizedDistance * Math.PI);
                    
                    const heightMultiplier = (waveValue + 1) / 2 * (1 - normalizedDistance * 0.5) + 0.2;
                    const baseHeight = 200;
                    const currentHeight = baseHeight * heightMultiplier;
                    
                    bar.style.height = currentHeight + 'px';
                    bar.style.opacity = 0.3 + heightMultiplier * 0.7;
                    
                    const hue = 180 + normalizedDistance * 180;
                    bar.style.background = `linear-gradient(to top, 
                        hsla(${hue}, 100%, 50%, 1) 0%, 
                        hsla(${hue + 60}, 100%, 50%, 0.8) 50%, 
                        hsla(${hue + 120}, 100%, 50%, 0.6) 100%)`;
                });
            }
            
            // 爱心形状模式
            function createHeart() {
                const waveBars = document.querySelectorAll('.wave-bar');
                const totalBars = waveBars.length;
                const center = totalBars / 2;
                
                waveBars.forEach((bar, index) => {
                    const x = (index - center) / center; // -1 到 1
                    const time = Date.now() / 1000;
                    
                    // 爱心函数 (简化版)
                    const heartY = Math.sqrt(1 - Math.pow(Math.abs(x) - 1, 2)) * 
                                  Math.sin(time * 2) * 0.5 + 0.5;
                    
                    const heightMultiplier = Math.max(0, heartY);
                    const baseHeight = 180;
                    const currentHeight = baseHeight * heightMultiplier;
                    
                    bar.style.height = currentHeight + 'px';
                    bar.style.opacity = 0.2 + heightMultiplier * 0.8;
                    
                    const hue = 300 + Math.sin(time + x) * 60; // 粉色系
                    bar.style.background = `linear-gradient(to top, 
                        hsla(${hue}, 100%, 60%, 1) 0%, 
                        hsla(${hue + 30}, 100%, 50%, 0.8) 50%, 
                        hsla(${hue + 60}, 100%, 40%, 0.6) 100%)`;
                });
            }
            
            // 螺旋模式
            function createSpiral() {
                const waveBars = document.querySelectorAll('.wave-bar');
                const totalBars = waveBars.length;
                
                waveBars.forEach((bar, index) => {
                    const angle = (index / totalBars) * Math.PI * 4; // 2圈螺旋
                    const time = Date.now() / 1000;
                    const radius = 0.3 + Math.sin(time * 2 + angle) * 0.2;
                    
                    const heightMultiplier = Math.max(0, radius);
                    const baseHeight = 160;
                    const currentHeight = baseHeight * heightMultiplier;
                    
                    bar.style.height = currentHeight + 'px';
                    bar.style.opacity = 0.3 + heightMultiplier * 0.7;
                    
                    const hue = (angle * 180 / Math.PI + time * 50) % 360;
                    bar.style.background = `linear-gradient(to top, 
                        hsla(${hue}, 100%, 50%, 1) 0%, 
                        hsla(${hue + 60}, 100%, 50%, 0.8) 50%, 
                        hsla(${hue + 120}, 100%, 50%, 0.6) 100%)`;
                });
            }
            
            // 随机模式
            function createRandom() {
                const waveBars = document.querySelectorAll('.wave-bar');
                
                waveBars.forEach((bar, index) => {
                    const randomHeight = Math.random() * 200 + 50;
                    const randomOpacity = Math.random() * 0.8 + 0.2;
                    const randomHue = Math.random() * 360;
                    
                    bar.style.height = randomHeight + 'px';
                    bar.style.opacity = randomOpacity;
                    bar.style.background = `linear-gradient(to top, 
                        hsla(${randomHue}, 100%, 50%, 1) 0%, 
                        hsla(${randomHue + 60}, 100%, 50%, 0.8) 50%, 
                        hsla(${randomHue + 120}, 100%, 50%, 0.6) 100%)`;
                });
            }
            
            // 主更新函数
            function updateWaves() {
                try {
                    // 每次更新时重新获取音浪条，确保不会因为元素被清理而停止
                    const waveBars = document.querySelectorAll('.wave-bar');
                    
                    // 如果没有音浪条，尝试重新初始化
                    if (waveBars.length === 0) {
                        console.log('音浪条丢失，重新初始化...');
                        initializeAudioWaves();
                        // 继续执行，不返回，确保音浪能够重新启动
                    }
                    
                    // 如果音浪条数量不足，也重新初始化
                    if (waveBars.length < 20) {
                        console.log('音浪条数量不足，重新初始化...');
                        initializeAudioWaves();
                    }
                    
                    modeTimer += 50; // 每50ms更新一次
                    
                    // 检查是否需要切换模式
                    if (modeTimer >= modeDuration) {
                        currentMode = (currentMode + 1) % modes.length;
                        modeTimer = 0;
                        console.log('切换到音浪模式:', modes[currentMode]);
                    }
                    
                    // 根据当前模式执行相应的效果
                    switch (modes[currentMode]) {
                        case 'wave':
                            createWave();
                            break;
                        case 'centerSpread':
                            createCenterSpread();
                            break;
                        case 'heart':
                            createHeart();
                            break;
                        case 'spiral':
                            createSpiral();
                            break;
                        case 'random':
                            createRandom();
                            break;
                    }
                } catch (error) {
                    console.error('音浪更新出错:', error);
                }
            }
        
        // 动态音浪效果 - 多种模式自动切换
        function startDynamicWaves() {
            // 如果已经有定时器在运行，先清除
            if (waveInterval) {
                clearInterval(waveInterval);
            }
            
            // 每50ms更新一次
            waveInterval = setInterval(updateWaves, 50);
            console.log('音浪循环已启动');
        }
        
        // 算法可视化全局变量
        let currentAlgorithm = 0;
        const algorithms = ['recursiveTree', 'neuralNetwork', 'sortingAlgorithm', 'linearRegression', 'clustering'];
        let algorithmTimer = 0;
        const algorithmDuration = 10000; // 每个算法显示10秒
        let algorithmInterval = null; // 算法定时器
        
        // 算法可视化系统
        function initAlgorithmVisualization() {
            
            // 递归树可视化
            function createRecursiveTree() {
                const container = document.getElementById('recursiveTree');
                container.innerHTML = '';
                
                function drawTree(x, y, length, angle, depth) {
                    if (depth <= 0) return;
                    
                    const endX = x + length * Math.cos(angle);
                    const endY = y + length * Math.sin(angle);
                    
                    // 绘制线条
                    const line = document.createElement('div');
                    line.className = 'tree-line';
                    line.style.left = x + 'px';
                    line.style.top = y + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
                    container.appendChild(line);
                    
                    // 绘制节点
                    const node = document.createElement('div');
                    node.className = 'tree-node';
                    node.style.left = (endX - 4) + 'px';
                    node.style.top = (endY - 4) + 'px';
                    node.style.animationDelay = (10 - depth) * 0.2 + 's';
                    container.appendChild(node);
                    
                    // 递归绘制子树
                    const newLength = length * 0.7;
                    const newAngle1 = angle - Math.PI / 6;
                    const newAngle2 = angle + Math.PI / 6;
                    
                    setTimeout(() => {
                        drawTree(endX, endY, newLength, newAngle1, depth - 1);
                        drawTree(endX, endY, newLength, newAngle2, depth - 1);
                    }, 200);
                }
                
                drawTree(150, 50, 80, -Math.PI / 2, 5);
            }
            
            // 神经网络可视化
            function createNeuralNetwork() {
                const container = document.getElementById('neuralNetwork');
                container.innerHTML = '';
                
                const layers = [4, 6, 4, 3]; // 每层神经元数量
                const layerSpacing = 100;
                const neuronSpacing = 40;
                
                // 创建神经元
                layers.forEach((neuronCount, layerIndex) => {
                    const layerY = 50 + layerIndex * layerSpacing;
                    
                    for (let i = 0; i < neuronCount; i++) {
                        const neuron = document.createElement('div');
                        neuron.className = 'neuron';
                        neuron.style.left = (50 + i * neuronSpacing) + 'px';
                        neuron.style.top = (layerY - 6) + 'px';
                        neuron.style.animationDelay = (layerIndex + i) * 0.1 + 's';
                        container.appendChild(neuron);
                    }
                });
                
                // 创建连接
                for (let layerIndex = 0; layerIndex < layers.length - 1; layerIndex++) {
                    const currentLayerCount = layers[layerIndex];
                    const nextLayerCount = layers[layerIndex + 1];
                    
                    for (let i = 0; i < currentLayerCount; i++) {
                        for (let j = 0; j < nextLayerCount; j++) {
                            const connection = document.createElement('div');
                            connection.className = 'neural-connection';
                            
                            const startX = 50 + i * neuronSpacing;
                            const startY = 50 + layerIndex * layerSpacing;
                            const endX = 50 + j * neuronSpacing;
                            const endY = 50 + (layerIndex + 1) * layerSpacing;
                            
                            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                            const angle = Math.atan2(endY - startY, endX - startX);
                            
                            connection.style.left = startX + 'px';
                            connection.style.top = startY + 'px';
                            connection.style.width = length + 'px';
                            connection.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
                            connection.style.animationDelay = (i + j) * 0.05 + 's';
                            
                            container.appendChild(connection);
                        }
                    }
                }
            }
            
            // 排序算法可视化
            function createSortingAlgorithm() {
                const container = document.getElementById('sortingAlgorithm');
                container.innerHTML = ''; // 确保完全清空
                
                // 强制清理所有可能的条形图元素
                const existingBars = document.querySelectorAll('.sort-bar');
                existingBars.forEach(bar => bar.remove());
                
                const barCount = 20;
                const barWidth = 15;
                const maxHeight = 150;
                let bars = [];
                
                // 创建初始数据
                for (let i = 0; i < barCount; i++) {
                    bars.push(Math.random() * maxHeight + 20);
                }
                
                // 创建条形图
                function renderBars() {
                    container.innerHTML = ''; // 每次渲染前清空
                    bars.forEach((height, index) => {
                        const bar = document.createElement('div');
                        bar.className = 'sort-bar';
                        bar.style.left = (index * (barWidth + 2)) + 'px';
                        bar.style.width = barWidth + 'px';
                        bar.style.height = height + 'px';
                        container.appendChild(bar);
                    });
                }
                
                // 冒泡排序动画
                async function bubbleSort() {
                    const n = bars.length;
                    for (let i = 0; i < n - 1; i++) {
                        for (let j = 0; j < n - i - 1; j++) {
                            // 高亮比较的元素
                            const bars_elements = container.querySelectorAll('.sort-bar');
                            if (bars_elements[j] && bars_elements[j + 1]) {
                                bars_elements[j].classList.add('comparing');
                                bars_elements[j + 1].classList.add('comparing');
                                
                                await new Promise(resolve => setTimeout(resolve, 100));
                                
                                if (bars[j] > bars[j + 1]) {
                                    // 交换元素
                                    [bars[j], bars[j + 1]] = [bars[j + 1], bars[j]];
                                    renderBars();
                                    await new Promise(resolve => setTimeout(resolve, 200));
                                }
                                
                                // 移除高亮
                                bars_elements[j].classList.remove('comparing');
                                bars_elements[j + 1].classList.remove('comparing');
                            }
                        }
                        
                        // 标记已排序的元素
                        const bars_elements = container.querySelectorAll('.sort-bar');
                        if (bars_elements[n - 1 - i]) {
                            bars_elements[n - 1 - i].classList.add('sorted');
                        }
                    }
                }
                
                renderBars();
                bubbleSort();
            }
            
            // 线性回归可视化
            function createLinearRegression() {
                const container = document.getElementById('linearRegression');
                container.innerHTML = '';
                
                // 生成随机数据点
                const dataPoints = [];
                const pointCount = 25;
                
                for (let i = 0; i < pointCount; i++) {
                    const x = Math.random() * 250 + 25;
                    const y = Math.random() * 150 + 25;
                    dataPoints.push({ x, y });
                }
                
                // 绘制数据点
                dataPoints.forEach((point, index) => {
                    const dataPoint = document.createElement('div');
                    dataPoint.className = 'data-point';
                    dataPoint.style.left = point.x + 'px';
                    dataPoint.style.top = point.y + 'px';
                    dataPoint.style.animationDelay = index * 0.1 + 's';
                    container.appendChild(dataPoint);
                });
                
                // 计算线性回归
                const n = dataPoints.length;
                const sumX = dataPoints.reduce((sum, p) => sum + p.x, 0);
                const sumY = dataPoints.reduce((sum, p) => sum + p.y, 0);
                const sumXY = dataPoints.reduce((sum, p) => sum + p.x * p.y, 0);
                const sumXX = dataPoints.reduce((sum, p) => sum + p.x * p.x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                // 绘制回归线
                const startX = 25;
                const endX = 275;
                const startY = slope * startX + intercept;
                const endY = slope * endX + intercept;
                
                const line = document.createElement('div');
                line.className = 'regression-line';
                line.style.left = startX + 'px';
                line.style.top = startY + 'px';
                
                const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const angle = Math.atan2(endY - startY, endX - startX);
                
                line.style.width = length + 'px';
                line.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
                container.appendChild(line);
            }
            
            // 聚类算法可视化 (K-means)
            function createClustering() {
                const container = document.getElementById('clustering');
                container.innerHTML = '';
                
                const k = 3; // 3个聚类
                const pointCount = 30;
                const points = [];
                
                // 生成随机数据点
                for (let i = 0; i < pointCount; i++) {
                    points.push({
                        x: Math.random() * 200 + 25,
                        y: Math.random() * 200 + 25,
                        cluster: Math.floor(Math.random() * k)
                    });
                }
                
                // 初始化聚类中心
                const centers = [];
                for (let i = 0; i < k; i++) {
                    centers.push({
                        x: Math.random() * 200 + 25,
                        y: Math.random() * 200 + 25
                    });
                }
                
                // K-means算法
                function kMeansIteration() {
                    // 分配点到最近的聚类中心
                    points.forEach(point => {
                        let minDist = Infinity;
                        let closestCenter = 0;
                        
                        centers.forEach((center, index) => {
                            const dist = Math.sqrt(
                                Math.pow(point.x - center.x, 2) + 
                                Math.pow(point.y - center.y, 2)
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                closestCenter = index;
                            }
                        });
                        
                        point.cluster = closestCenter;
                    });
                    
                    // 更新聚类中心
                    centers.forEach((center, index) => {
                        const clusterPoints = points.filter(p => p.cluster === index);
                        if (clusterPoints.length > 0) {
                            center.x = clusterPoints.reduce((sum, p) => sum + p.x, 0) / clusterPoints.length;
                            center.y = clusterPoints.reduce((sum, p) => sum + p.y, 0) / clusterPoints.length;
                        }
                    });
                }
                
                // 执行几次迭代
                for (let i = 0; i < 5; i++) {
                    kMeansIteration();
                }
                
                // 绘制数据点
                points.forEach((point, index) => {
                    const clusterPoint = document.createElement('div');
                    clusterPoint.className = `cluster-point cluster-${point.cluster + 1}`;
                    clusterPoint.style.left = point.x + 'px';
                    clusterPoint.style.top = point.y + 'px';
                    clusterPoint.style.animationDelay = index * 0.05 + 's';
                    container.appendChild(clusterPoint);
                });
                
                // 绘制聚类中心
                centers.forEach((center, index) => {
                    const clusterCenter = document.createElement('div');
                    clusterCenter.className = `cluster-center center-${index + 1}`;
                    clusterCenter.style.left = (center.x - 6) + 'px';
                    clusterCenter.style.top = (center.y - 6) + 'px';
                    clusterCenter.style.animationDelay = index * 0.2 + 's';
                    container.appendChild(clusterCenter);
                });
            }
            
            // 强制清理所有算法元素
            function clearAllAlgorithms() {
                algorithms.forEach(name => {
                    const element = document.getElementById(name);
                    element.style.opacity = '0';
                    element.innerHTML = '';
                });
                
                // 额外清理：移除所有可能的条形图元素
                const allBars = document.querySelectorAll('.sort-bar');
                allBars.forEach(bar => bar.remove());
            }
            
            // 显示当前算法
            function showAlgorithm(algorithmName) {
                // 强制清理所有算法
                clearAllAlgorithms();
                
                // 显示当前算法
                setTimeout(() => {
                    const currentElement = document.getElementById(algorithmName);
                    currentElement.style.opacity = '1';
                    
                    // 重新创建算法
                    switch (algorithmName) {
                        case 'recursiveTree':
                            createRecursiveTree();
                            break;
                        case 'neuralNetwork':
                            createNeuralNetwork();
                            break;
                        case 'sortingAlgorithm':
                            createSortingAlgorithm();
                            break;
                        case 'linearRegression':
                            createLinearRegression();
                            break;
                        case 'clustering':
                            createClustering();
                            break;
                    }
                }, 1000);
            }
            
            // 主更新函数
            function updateAlgorithms() {
                try {
                    algorithmTimer += 100; // 每100ms更新一次
                    
                    // 检查是否需要切换算法
                    if (algorithmTimer >= algorithmDuration) {
                        currentAlgorithm = (currentAlgorithm + 1) % algorithms.length;
                        algorithmTimer = 0;
                        console.log('切换到算法:', algorithms[currentAlgorithm]);
                        showAlgorithm(algorithms[currentAlgorithm]);
                    }
                } catch (error) {
                    console.error('算法更新出错:', error);
                }
            }
            
            // 初始化第一个算法
            showAlgorithm(algorithms[0]);
            
            // 如果已经有定时器在运行，先清除
            if (algorithmInterval) {
                clearInterval(algorithmInterval);
            }
            
            // 每100ms更新一次
            algorithmInterval = setInterval(updateAlgorithms, 100);
            console.log('算法循环已启动');
        }
        
        // 初始化
        populateCodeDisplay();
        
        // 初始化音浪效果
        initializeAudioWaves();
        
        // 启动音浪动画
        startDynamicWaves();
        
        // 初始化算法可视化
        initAlgorithmVisualization();
        
        // 检测调酒师图片
        const bartender = document.querySelector('.bartender');
        checkImageExists('bartender.png', bartender, 'has-image');
        
        // 检测吧台图片
        const barCounter = document.querySelector('.bar-counter');
        checkImageExists('bar-counter.png', barCounter, 'has-image');
        
        // 定期添加新代码行 - 优化频率
        setInterval(addNewCodeLine, 4000);
        
        // 随机改变字符颜色 - 优化性能
        setInterval(() => {
            const chars = document.querySelectorAll('.code-char');
            // 只改变少量字符，减少重绘
            const sampleSize = Math.min(chars.length, 8);
            for (let i = 0; i < sampleSize; i++) {
                const randomIndex = Math.floor(Math.random() * chars.length);
                if (Math.random() < 0.05) {
                    chars[randomIndex].style.color = Math.random() < 0.5 ? '#0f0' : '#0ff';
                }
            }
        }, 4000);
        
        // 对话系统
        class DialogueSystem {
            constructor() {
                this.container = document.getElementById('dialogueContainer');
                this.currentStep = 0;
                this.userChoices = {
                    melody: null,
                    style: null,
                    mbti: null
                };
                this.dialogueQueue = [];
                this.isWaitingForClick = false;
                
                // 预加载音效
                this.preloadAudio();
                this.init();
            }
            
            init() {
                this.showWelcome();
            }
            
            // 预加载音效
            preloadAudio() {
                try {
                    this.glassAudio = new Audio('glass-clink.mp3');
                    this.glassAudio.preload = 'auto';
                    this.glassAudio.volume = 0.7;
                    console.log('音效预加载完成');
                } catch (e) {
                    console.log('音效预加载失败:', e);
                }
            }
            
            showWelcome() {
                this.dialogueQueue = [
                    { speaker: 'stella', name: 'Stella', text: '晚上好，一位新客人。欢迎来到「旋律酿造厂」，一个能用声音调制鸡尾酒的地方。我是这里的调酒师，Stella。看起来，您想尝试一杯特调的"声音鸡尾酒"？', showClick: true },
                    { action: 'choices', choices: ['开始调制', '了解更多'] }
                ];
                this.processNextDialogue();
            }
            
            processNextDialogue() {
                if (this.dialogueQueue.length === 0) return;
                
                const next = this.dialogueQueue.shift();
                
                if (next.action === 'choices') {
                    this.addChoiceButtons(next.choices);
                } else if (next.action === 'recording') {
                    this.addRecordingButton();
                } else if (next.action === 'next_step') {
                    this[next.step]();
                } else {
                    this.addBubble(next.speaker, next.name, next.text, next.showClick);
                }
            }
            
            addBubble(speaker, name, text, showClickHint = true) {
                // 清除之前的对话气泡
                this.clearBubbles();
                
                const bubble = document.createElement('div');
                bubble.className = `dialogue-bubble ${speaker}`;
                bubble.innerHTML = `
                    <div class="speaker-name ${speaker}">${name}</div>
                    <div>${text}</div>
                    ${showClickHint ? '<div class="click-to-continue">点击继续...</div>' : ''}
                `;
                
                // 添加点击事件
                if (showClickHint) {
                    bubble.addEventListener('click', () => {
                        this.handleBubbleClick();
                    });
                }
                
                this.container.appendChild(bubble);
                this.scrollToBottom();
                this.isWaitingForClick = showClickHint;
            }
            
            handleBubbleClick() {
                if (this.isWaitingForClick) {
                    this.isWaitingForClick = false;
                    this.processNextDialogue();
                }
            }
            
            addChoiceButtons(choices) {
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'choice-buttons';
                
                choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.className = 'choice-btn';
                    button.textContent = choice;
                    button.onclick = () => this.handleChoice(choice);
                    buttonContainer.appendChild(button);
                });
                
                this.container.appendChild(buttonContainer);
                this.scrollToBottom();
            }
            
            addRecordingButton() {
                const button = document.createElement('button');
                button.className = 'recording-btn';
                button.textContent = '🎤 开始录制';
                button.onclick = () => this.startRecording();
                this.container.appendChild(button);
                this.scrollToBottom();
            }
            
            handleChoice(choice) {
                this.clearChoices();
                
                switch(choice) {
                    case '开始调制':
                        this.step1_BaseMelody();
                        break;
                    case '了解更多':
                        this.addBubble('stella', 'Stella', '「旋律酿造厂」是一个神奇的地方，在这里，您的歌声会变成调酒的原料。每一段旋律都有它独特的"味道"，而我的工作就是将这些"味道"融合成一杯完美的音乐鸡尾酒。');
                        this.addChoiceButtons(['听起来很有趣，开始吧！']);
                        break;
                    case '听起来很有趣，开始吧！':
                        this.step1_BaseMelody();
                        break;
                    case '爵士':
                    case '电子':
                    case '古典':
                    case '流行':
                    case 'Lo-fi':
                    case '摇滚':
                        this.userChoices.style = choice;
                        this.step3_Personality();
                        break;
                    case 'I型（内向）':
                        this.userChoices.mbti = 'I';
                        this.askMBTI_N();
                        break;
                    case 'E型（外向）':
                        this.userChoices.mbti = 'E';
                        this.askMBTI_N();
                        break;
                    case 'N型（直觉）':
                        this.userChoices.mbti += 'N';
                        this.askMBTI_F();
                        break;
                    case 'S型（感觉）':
                        this.userChoices.mbti += 'S';
                        this.askMBTI_F();
                        break;
                    case 'F型（情感）':
                        this.userChoices.mbti += 'F';
                        this.askMBTI_J();
                        break;
                    case 'T型（思考）':
                        this.userChoices.mbti += 'T';
                        this.askMBTI_J();
                        break;
                    case 'J型（判断）':
                        this.userChoices.mbti += 'J';
                        this.finalStep();
                        break;
                    case 'P型（感知）':
                        this.userChoices.mbti += 'P';
                        this.finalStep();
                        break;
                    case '开始录制':
                        this.startRecording();
                        break;
                    case '重新调制':
                        // 隐藏鸡尾酒
                        this.hideCocktail();
                        // 重置用户选择
                        this.userChoices = {
                            melody: null,
                            style: null,
                            mbti: null
                        };
                        // 重新开始对话
                        this.showWelcome();
                        break;
                    case '结束对话':
                        this.addBubble('stella', 'Stella', '感谢您的光临！期待下次再见。', false);
                        break;
                }
            }
            
            step1_BaseMelody() {
                this.dialogueQueue = [
                    { speaker: 'stella', name: 'Stella', text: '太好了。我的工作，就是将您带来的独特"原料"，融合成一杯只属于您的音乐。那么，我们开始吧？首先，我需要您提供三种核心的"基酒"和"风味"。', showClick: true },
                    { speaker: 'stella', name: 'Stella', text: '每一杯经典的鸡尾酒，都离不开一份优质的"基酒"。请您为我"哼唱"一段旋律吧，无论是一段熟悉的副歌，还是您脑海中突然闪过的灵感片段都可以。它将是这杯音乐最原始的底色。', showClick: true },
                    { action: 'recording' }
                ];
                this.processNextDialogue();
            }
            
            startRecording() {
                const button = document.querySelector('.recording-btn');
                if (button) {
                    button.textContent = '⏹️ 停止录制';
                    button.classList.add('recording');
                    
                    // 修改按钮点击事件为停止录制
                    button.onclick = () => this.stopRecording();
                }
            }
            
            stopRecording() {
                const button = document.querySelector('.recording-btn');
                if (button) {
                    button.textContent = '✅ 录制完成';
                    button.classList.remove('recording');
                    
                    // 恢复按钮点击事件
                    button.onclick = () => this.startRecording();
                    
                    setTimeout(() => {
                        this.step1_Complete();
                    }, 1000);
                }
            }
            
            step1_Complete() {
                // 清除录制按钮
                this.clearChoices();
                
                this.dialogueQueue = [
                    { speaker: 'stella', name: 'Stella', text: '嗯……我收到了，一段非常灵动的旋律。很好的开端，这瓶"基酒"潜力无穷。', showClick: true },
                    { speaker: 'stella', name: 'Stella', text: '基酒已备，接下来是决定风味的时候了。您希望您的这杯音乐，是哪种"口感"呢？', showClick: true },
                    { action: 'next_step', step: 'step2_Style' }
                ];
                this.processNextDialogue();
            }
            
            step2_Style() {
                this.dialogueQueue = [
                    { speaker: 'stella', name: 'Stella', text: '是想来点爵士的微醺与暧昧，像一杯Old Fashioned？还是电子音乐的冰凉与炸裂，如同一杯Mojito？或者，您偏爱古典的醇厚与复杂，像一杯层次丰富的Manhattan？请告诉我您的选择。', showClick: true },
                    { action: 'choices', choices: ['爵士', '电子', '古典', '流行', 'Lo-fi', '摇滚'] }
                ];
                this.processNextDialogue();
            }
            
            step3_Personality() {
                this.dialogueQueue = [
                    { speaker: 'stella', name: 'Stella', text: `明智之选。${this.userChoices.style}的风味，总能带来意想不到的惊喜。我已经能想象它和您的旋律融合后的样子了。`, showClick: true },
                    { speaker: 'stella', name: 'Stella', text: '最后，也是我最引以为傲的环节——注入一丝您的个人色彩。这就像鸡尾酒里那滴神秘的"苦精"，看似微不足道，却能让整杯酒拥有独一无二的灵魂。', showClick: true },
                    { action: 'next_step', step: 'askMBTI_I' }
                ];
                this.processNextDialogue();
            }
            
            askMBTI_I() {
                this.addBubble('stella', 'Stella', '您是i人还是e人？', false);
                this.addChoiceButtons(['I型（内向）', 'E型（外向）']);
            }
            
            askMBTI_N() {
                this.addBubble('stella', 'Stella', '您是n人还是s人？', false);
                this.addChoiceButtons(['N型（直觉）', 'S型（感觉）']);
            }
            
            askMBTI_F() {
                this.addBubble('stella', 'Stella', '您是f人还是t人？', false);
                this.addChoiceButtons(['F型（情感）', 'T型（思考）']);
            }
            
            askMBTI_J() {
                this.addBubble('stella', 'Stella', '您是j人还是p人？', false);
                this.addChoiceButtons(['J型（判断）', 'P型（感知）']);
            }
            
            addMBTIChoices() {
                const mbtiTypes = [
                    'INTJ', 'INTP', 'ENTJ', 'ENTP',
                    'INFJ', 'INFP', 'ENFJ', 'ENFP',
                    'ISTJ', 'ISFJ', 'ESTJ', 'ESFJ',
                    'ISTP', 'ISFP', 'ESTP', 'ESFP'
                ];
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'choice-buttons';
                
                // 显示前8个类型
                mbtiTypes.slice(0, 8).forEach(type => {
                    const button = document.createElement('button');
                    button.className = 'choice-btn';
                    button.textContent = type;
                    button.onclick = () => this.handleMBTIChoice(type);
                    buttonContainer.appendChild(button);
                });
                
                this.container.appendChild(buttonContainer);
                this.scrollToBottom();
            }
            
            handleMBTIChoice(mbti) {
                this.userChoices.mbti = mbti;
                this.clearChoices();
                this.finalStep();
            }
            
            finalStep() {
                this.addBubble('stella', 'Stella', `（眼神中闪过一丝了然）啊，原来是${this.userChoices.mbti}。我明白了。这瓶"秘料"会让最终的作品更加贴合您的气质。感谢您的分享。`);
                setTimeout(() => {
                    this.addBubble('stella', 'Stella', '完美！所有的原料都已集齐。\n您的个人旋律——我们的生命之水。\n' + this.userChoices.style + '——我们的风味利口酒。\n还有' + this.userChoices.mbti + '的人格特质——那点睛之笔的灵魂秘料。');
                    setTimeout(() => {
                        this.addBubble('stella', 'Stella', '现在，请稍坐片刻，让我为您现场"调制"。这需要一点魔法和时间。');
                        this.showMixingAnimation();
                    }, 2000);
                }, 2000);
            }
            
            showMixingAnimation() {
                const mixingBubble = document.createElement('div');
                mixingBubble.className = 'dialogue-bubble stella';
                mixingBubble.innerHTML = `
                    <div class="speaker-name stella">Stella</div>
                    <div>🔮 正在生成您的音乐鸡尾酒…</div>
                    <div style="margin-top: 10px; font-size: 14px; color: #ff00ff;">
                        ✨ 调制中... ✨ 融合旋律... ✨ 注入风格... ✨ 添加人格特质...
                    </div>
                `;
                this.container.appendChild(mixingBubble);
                this.scrollToBottom();
                
                // 模拟调制过程
                setTimeout(() => {
                    // 先显示鸡尾酒
                    this.showCocktail(this.userChoices.mbti);
                    // 然后显示最终结果
                    setTimeout(() => {
                        this.showFinalResult();
                    }, 500);
                }, 5000);
            }
            
            showFinalResult() {
                const drinkNames = {
                    'INTJ': 'INTJ的月光小夜曲',
                    'INTP': 'INTP的电路桑格利亚',
                    'ENTJ': 'ENTJ的王者马提尼',
                    'ENTP': 'ENTP的电路桑格利亚',
                    'INFJ': 'INFJ的月光小夜曲',
                    'INFP': 'INFP的梦幻莫吉托',
                    'ENFJ': 'ENFJ的温暖威士忌',
                    'ENFP': 'ENFP的活力朗姆酒',
                    'ISTJ': 'ISTJ的经典马提尼',
                    'ISFJ': 'ISFJ的温柔威士忌',
                    'ESTJ': 'ESTJ的权威朗姆酒',
                    'ESFJ': 'ESFJ的温暖香槟',
                    'ISTP': 'ISTP的冒险龙舌兰',
                    'ISFP': 'ISFP的艺术莫吉托',
                    'ESTP': 'ESTP的活力伏特加',
                    'ESFP': 'ESFP的欢乐桑格利亚'
                };
                
                const drinkName = drinkNames[this.userChoices.mbti] || `${this.userChoices.mbti}的特调鸡尾酒`;
                
                this.addBubble('stella', 'Stella', `（将一杯泛着微光、仿佛有音符在流动的"虚拟鸡尾酒"推到用户面前）您的特调，「${drinkName}」，完成了。`);
                setTimeout(() => {
                    this.addBubble('stella', 'Stella', '请点击酒杯，聆听您的专属音乐。希望这杯由您亲自参与酿造的声音，能带给您一段美妙的时光。如果喜欢，随时可以回来，我们再换一种配方。');
                    this.addChoiceButtons(['重新调制', '结束对话']);
                }, 2000);
            }
            
            // 显示鸡尾酒图片
            showCocktail(mbti) {
                const cocktailDisplay = document.getElementById('cocktailDisplay');
                const cocktailImage = document.getElementById('cocktailImage');
                
                // 设置鸡尾酒图片
                const imagePath = `cocktails/${mbti.toLowerCase()}.png`;
                cocktailImage.style.backgroundImage = `url('${imagePath}')`;
                
                // 显示鸡尾酒
                cocktailDisplay.classList.add('show');
                
                // 添加点击事件监听器
                cocktailImage.onclick = () => this.playCocktailSound();
            }
            
            // 播放鸡尾酒音效
            playCocktailSound() {
                // 添加点击效果
                const cocktailImage = document.getElementById('cocktailImage');
                cocktailImage.style.transform = 'scale(0.9)';
                
                // 播放酒杯碰撞音效
                this.playGlassSound().then(() => {
                    // 音效播放完成后恢复图片大小
                    setTimeout(() => {
                        cocktailImage.style.transform = 'scale(1)';
                    }, 150);
                    
                    // 显示音乐播放提示
                    this.showMusicPlaybackMessage();
                }).catch(e => {
                    console.log('音频播放失败:', e);
                    // 即使音效失败也要恢复图片大小
                    setTimeout(() => {
                        cocktailImage.style.transform = 'scale(1)';
                    }, 150);
                });
            }
            
            // 播放酒杯音效
            playGlassSound() {
                return new Promise((resolve, reject) => {
                    try {
                        if (this.glassAudio) {
                            // 使用预加载的音频
                            this.glassAudio.currentTime = 0; // 重置播放位置
                            this.glassAudio.play().then(() => {
                                // 音效播放完成
                                setTimeout(() => {
                                    resolve();
                                }, this.glassAudio.duration * 1000);
                            }).catch(reject);
                        } else {
                            // 如果预加载失败，创建新的音频
                            const audio = new Audio('glass-clink.mp3');
                            audio.volume = 0.7;
                            audio.play().then(() => {
                                setTimeout(() => {
                                    resolve();
                                }, audio.duration * 1000);
                            }).catch(reject);
                        }
                    } catch (e) {
                        console.log('音频播放失败:', e);
                        resolve(); // 即使失败也继续执行
                    }
                });
            }
            
            // 显示音乐播放提示
            showMusicPlaybackMessage() {
                this.addBubble('stella', 'Stella', '🎵 美妙的音乐开始流淌... 请戴上耳机，享受您的专属旋律！', false);
                
                // 3秒后显示操作提示
                setTimeout(() => {
                    this.addBubble('stella', 'Stella', '💡 提示：您可以随时点击"重新调制"来尝试不同的音乐风格。', false);
                }, 3000);
            }
            
            // 隐藏鸡尾酒
            hideCocktail() {
                const cocktailDisplay = document.getElementById('cocktailDisplay');
                cocktailDisplay.classList.remove('show');
            }
            
            clearBubbles() {
                const bubbles = this.container.querySelectorAll('.dialogue-bubble');
                bubbles.forEach(bubble => bubble.remove());
            }
            
            clearChoices() {
                const buttons = this.container.querySelectorAll('.choice-buttons, .recording-btn');
                buttons.forEach(btn => btn.remove());
            }
            
            scrollToBottom() {
                this.container.scrollTop = this.container.scrollHeight;
            }
        }
        
        // 初始化对话系统
        const dialogueSystem = new DialogueSystem();
    </script>
</body>
</html>